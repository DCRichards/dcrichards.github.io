    <!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.15" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> DCRichards &middot; /etc/davi.d </title>

    <link rel="stylesheet" href="http://dcrichards.com/blog/css/syntax.css">
    <link rel="stylesheet" href="http://dcrichards.com/blog/css/style.css">
   
    <link href='https://fonts.googleapis.com/css?family=Lato:400,400italic,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Work+Sans:400,700,500' rel='stylesheet' type='text/css'> 
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

	<body class="">
		
        <div class="sidebar">
    <div class="container sidebar-sticky">
        <div class="sidebar-about">
            <a href="http://dcrichards.com/blog"><h1>/etc/davi.d</h1></a>
            <div class="image-wrapper">
                <div class="image-container">
                    
                </div>
            </div>
            <p class="lead">please allow me to get my spectacles and convey something technical</p>
            <div class="sidebar-footer">
                A blog by <a href="http://dcrichards.com" class="back-link">David Richards</a>
                <br />
                <br />
                <br />
                David is a Software Developer at Ocasta Studios, Brighton
            </div>
        </div>
    </div>
</div>


		<div class="content container">
			<div class="post">
			 	<h1>Apple Watch: Complications</h1>
			     <span class="post-date">17 November 2015</span>
			     

<p>Recently, I&rsquo;ve been getting stuck into some Apple Watch development. Whilst WatchOS 2 provides some useful APIs and functionality, there is a distinct lack of good documentation that isn&rsquo;t buried deep in the badly presented WWDC videos. For this reason, I&rsquo;ve decided to add my two cents and present my learnings so far in something more fluent, coherent and useful than Apple&rsquo;s lacklustre efforts.</p>

<p>I should note that the following is written with Objective-C rather than the more modern and syntactically paletable Swift but those familiar with both shouldn&rsquo;t struggle to make the conversion. For reference, the official documentation can be found in the <a href="https://developer.apple.com/library/watchos/documentation/General/Conceptual/AppleWatch2TransitionGuide/CreatingaComplication.html">WatchOS 2 Transition Guide</a> as well as in the relevant <a href="https://developer.apple.com/library/watchos/documentation/WatchKit/Reference/WatchKit_framework/index.html">WatchKit Framework documentation</a> which contains examples in both languages.</p>

<h3 id="some-context:1528dbce263a8191b2123ab27d4b3625">Some Context</h3>

<p><em>TL;DR: A complication is a watchface widget which can be updated and used to access watch app information and display it to the user.</em></p>

<p>The above is most of what you need to know about complications from a user perspective. Delving deeper, there a number of complication families which are different shapes and sizes and can be displayed in various positions on a watchface. This useful diagram, taken from the <a href="https://developer.apple.com/library/watchos/documentation/General/Conceptual/WatchKitProgrammingGuide/ComplicationEssentials.html#//apple_ref/doc/uid/TP40014969-CH27-SW1">WatchOS 2 documentation</a> outlines these families.</p>

<p><img src="https://developer.apple.com/library/watchos/documentation/General/Conceptual/WatchKitProgrammingGuide/Art/complication_styles_2x.png" alt="" /></p>

<h3 id="complication-controller:1528dbce263a8191b2123ab27d4b3625">Complication Controller</h3>

<p>If you selected the <em>Include Complication</em> checkbox when creating your watch app in XCode then the files <strong>ComplicationController.h</strong> and <strong>ComplicationController.m</strong> will have been created for you in your WatchKit Extension. As an aside, I&rsquo;m yet to be able to make this work without doing this from the start, adding the ClockKit library manually still produces various not found errors. Anyone with light to shed here is strongly encouraged to drop me a line.</p>

<p>In the header, we&rsquo;re going to need to add two imports <code>WatchKit/WKExtension.h</code> and <code>ExtensionDelegate.h</code> as these will be used when delegating to our extension to fetch the data for our complication. We&rsquo;re also going to add a class method here, which we will use to prompt the complication controller to fetch new data, in this case <code>notifyOfUpdate</code>.</p>

<p><strong>ComplicationController.h</strong></p>

<pre><code>#import &lt;ClockKit/ClockKit.h&gt;
#import &lt;WatchKit/WKExtension.h&gt;
#import &quot;ExtensionDelegate.h&quot;

@interface ComplicationController : NSObject &lt;CLKComplicationDataSource&gt;

+ (void) notifyOfUpdate;

@end
</code></pre>

<p>In the implementation, you&rsquo;ll notice that the pre-made class comes with a number of stub methods, the majority of the work here is fleshing the appropriate ones out. First, let&rsquo;s look at how we&rsquo;ll grab our data. The method <code>getCurrentTimelineEntryForComplication:withHandler</code> is what will actually do the fetching of data and updating of the timeline. We don&rsquo;t have direct control over this method and this is instead called on either a scheduled or manually triggered update. We won&rsquo;t focus on the schedule part here, but I may discuss the timeline feature of complications in the future. The first thing to note is that we must get the instance of our extension delegate, this is also handled by the framework:</p>

<pre><code>ExtensionDelegate* extDelegate = (ExtensionDelegate*)[[WKExtension sharedExtension];
</code></pre>

<p>We can then make calls to the delegate in the ususal way, in our case, this is to fetch an object of type <code>UIImage</code> using the method <code>getComplicationImage</code> which will be displayed on our complication:</p>

<pre><code>CLKImageProvider* provider = [CLKImageProvider imageProviderWithOnePieceImage: [extDelegate getComplicationImage]]; 
</code></pre>

<p>Note that although I&rsquo;ve used a switch statement here, there are arguments for using an if statement. For clarity and brevity, I&rsquo;ve opted for a switch  statement and only implemented two complication families. Some families have more complex layouts but for now, we&rsquo;ll keep it simple. Below is the method in its entirety.</p>

<p><strong>ComplicationController.m</strong></p>

<pre><code>- (void)getCurrentTimelineEntryForComplication:(CLKComplication *)complication withHandler:(void(^)(CLKComplicationTimelineEntry * __nullable))handler {

    CLKComplicationTimelineEntry* entry;
    NSDate* now = [NSDate date];
    CLKComplicationTemplate* template;
    ExtensionDelegate* extDelegate = (ExtensionDelegate*)[[WKExtension sharedExtension] delegate];
    CLKImageProvider* provider = [CLKImageProvider imageProviderWithOnePieceImage: [extDelegate getComplicationImage]];

    switch (complication.family) {

        case CLKComplicationFamilyModularSmall:
            template = [[CLKComplicationTemplateModularSmallSimpleImage alloc] init];
            [(CLKComplicationTemplateModularSmallSimpleImage*) template setImageProvider: provider];
            entry = [CLKComplicationTimelineEntry entryWithDate: now complicationTemplate: template];
            break;

        case CLKComplicationFamilyUtilitarianSmall:
            template = [[CLKComplicationTemplateUtilitarianSmallRingImage alloc] init];
            [(CLKComplicationTemplateUtilitarianSmallRingImage*) template setImageProvider: provider];
            entry = [CLKComplicationTimelineEntry entryWithDate: now complicationTemplate: template];
            break;

        default:
            break;
    }

    handler(entry);
}
</code></pre>

<p>All that remains is to flesh out the <code>notifyOfUpdate</code> method. It should be noted that updates to complications are <strong>budgeted</strong> and subject to a daily allowance. There appears to be no indication of what this limit is, but complications exceeding this are prevented from updating until the following day. Right now, it also doesn&rsquo;t appear to possible to identify a particular complication so instead we iterate through the list of active complications (when I tested this only one was returned, but I&rsquo;m yet to test with multiple custom complications).</p>

<pre><code>+ (void) notifyOfUpdate {
    CLKComplicationServer* compServer = [CLKComplicationServer sharedInstance];
    for (CLKComplication* comp in [compServer activeComplications]) {
        [compServer reloadTimelineForComplication:comp];
    }
} 
</code></pre>

<h3 id="extension-delegate:1528dbce263a8191b2123ab27d4b3625">Extension Delegate</h3>

<p>To connect the dots and be able to provide data to and update our complication we need to provide an implementation of <code>getComplicationImage</code>. For the purposes of this example, we&rsquo;re just going to return an image based on a boolean value (in this case, some kind of readiness indicator) but we won&rsquo;t dwell on the details here.</p>

<p><strong>ExtensionDelegate.m</strong></p>

<pre><code>- (UIImage*)getComplicationImage {
    return [UIImage imageNamed: self.isReady ? @&quot;ready.png&quot; : @&quot;waiting.png&quot;];
}
</code></pre>

<p>Finally, we need to trigger the update. Depending on the implementation, this may be a message or some kind of touch interaction. By way of example, we&rsquo;ll suppose there is a <code>didBecomeReady</code> method which is called at the appropriate time. We must make sure that we&rsquo;ve remembered to import <code>ComplicationController.h</code> into our header.</p>

<pre><code>- (void)didBecomeReady {
    [ComplicationController notifyOfUpdate];
}
</code></pre>

<h3 id="placeholder-template:1528dbce263a8191b2123ab27d4b3625">Placeholder Template</h3>

<p>That&rsquo;s it for the bare bones, but it&rsquo;s worth briefly mentioning one more thing here. The method <code>getPlaceholderTemplateForComplication:withHandler</code> is, as the name suggests, for providing a default template for the complication. This is the one seen when adding it to a watchface. The implementation details are similar to our <code>getCurrentTimelineEntryForComplication:withHandler</code> method, except we pass a template rather than an entry back to our handler. By implementing this, you&rsquo;ll make sure your user sees a reasonable preview of your complication when adding it to their chosen watchface.</p>

<pre><code>- (void)getPlaceholderTemplateForComplication:(CLKComplication *)complication withHandler:(void(^)(CLKComplicationTemplate * __nullable complicationTemplate))handler {

    CLKComplicationTemplate* template;

    if (complication.family == CLKComplicationFamilyModularSmall) {
        template = [[CLKComplicationTemplateModularSmallSimpleImage alloc] init];
        UIImage* img = [UIImage imageNamed:@&quot;default.png&quot;];
        CLKImageProvider* provider = [CLKImageProvider imageProviderWithOnePieceImage: img];
        [(CLKComplicationTemplateModularSmallSimpleImage*) template setImageProvider: provider];
    }

    handler(template);
}
</code></pre>

			</div>
		</div>

    </body>
</html>
